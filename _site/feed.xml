<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-11-30T04:10:18-05:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Alex’s Blog</title><subtitle>This is Alex&apos;s blog for machine learning.</subtitle><entry><title type="html">An Anthology for Linear Regresion</title><link href="http://localhost:4000/jekyll/update/2024/11/29/bayesian-linear-regression.html" rel="alternate" type="text/html" title="An Anthology for Linear Regresion" /><published>2024-11-29T00:07:44-05:00</published><updated>2024-11-29T00:07:44-05:00</updated><id>http://localhost:4000/jekyll/update/2024/11/29/bayesian-linear-regression</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2024/11/29/bayesian-linear-regression.html"><![CDATA[<h1 id="1-introduction">1. <strong>Introduction</strong></h1>
<hr />
<p>Things are easy when they’re simple. As far as curves go, linear curves are about as nice as it gets.</p>

<p>I present to you a rough anthology of linear regression.<sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>  By this, I mean several different approaches to linear regression. We’ll start off with minimizing MSE and end up with a Bayesian approach with hopefully a (semi-)rigorous approach throughout. Ideally, everything should <em>feel</em> motivated.</p>

<p>There are several computational tricks / alternative derivations which making things shorter and easier. These methods are also cleverer. I’ll go through some of them at the end of the article but it’s probably valuable to do it the painful way at least once.</p>

<h1 id="2-problem-set-up">2. <strong>Problem Set up</strong></h1>
<hr />

<p>We begin with a dataset $\mathcal{D} = {(x_i, y_i)}_{i= 1}^n$. Let $y \in \mathbb{R}, x \in \mathbb{R}^d$. We want to find a linear relationship between features $x_i$ and noisy target values $y_i$, i.e.:</p>

\[y_i = f(x_i) + \epsilon_x\]

<p>If we believe the underlying relationship between $y$ and $x$ is in fact linear, we set</p>

\[f(x_i) = w^T x_i\]

<p>where $w$ represents the weights or scaling coefficients.</p>

<p>We can collect the target values $y_1, \dots, y_n$ into a vector $y$ and the feature vectors $x_1, \dots, x_N$ into a <strong>design matrix</strong> $X$ where the row $X_i = x_i$. This ensures each $y_i = x_i^T w$.</p>

\[y = X w + \epsilon_x\]

<p>Note that this represents $y$ as a column vector.</p>

<h1 id="3-minimize-mse">3. <strong>Minimize MSE</strong></h1>
<hr />

<p>The first perspective on linear regression is just minimizing the error between the targets $y$ and the predictions $Xw$. We’ll derive this with matrix calculus<sup id="fnref:2"><a href="#fn:2" class="footnote" rel="footnote" role="doc-noteref">2</a></sup>.The residual (error between $Xw$ and $y$) is defined as:</p>

\[e = y - Xw\]

<p>We want to find the $\hat{w}$ that minimizes the <strong>mean-squared error</strong>:</p>

\[\hat{w} = \argmin_{w} \ e^T e = \argmin_{w} \ (y - Xw)^T (y - Xw)\]

<p>For optimization problems like this, we can just take the first derivative w.r.t $w$ and set to $0$.</p>

\[0 = \frac{\partial e^T e}{\partial w} = \frac{\partial}{\partial w} (y - Xw)^T (y - Xw)\]

\[= \frac{\partial}{\partial w} (y^T y + w^T X^T X w - 2 w^T X^T y)\]

<p>There are two ways to treat matrix derivatives. Numerator layout (treating the gradient as row vector) and denominator layout (treating the gradient as a column vector). This actually caused me great grief when I was learning this on my own but I’ve kinda gotten over it. So both views are presented here.</p>

<p>Here are the rules we will use (treating the gradient as a row vector). To treat the gradient as a column vector, take the transpose.</p>

\[\frac{\partial}{\partial x} x^T a = \frac{\partial}{\partial x} a^T x = a^T\]

\[\frac{\partial}{\partial x} x^T A x = x^T (A + A^T)\]

<p>To verify these rules for yourself, you can just convert these matrix-vector products into sums.</p>

<h4 id="31-gradient-is-a-row-vector">3.1 <strong>Gradient is a Row Vector</strong></h4>
<hr />

<p>The first term ($y^T y$) is not dependent on $w$ so it goes to zero. The second term becomes $2 w^T X^T X$. The third term becomes $2 y^T X$. So we have:</p>

\[0 = 2 w^T X^T X - 2 y^T X\]

\[y^T X = w^T X^T X\]

\[w^T = y^T X (X^T X)^{-1}\]

\[w = (X^T X)^{-1} X^T y\]

<p>If a symmetric matrix is non-singular, it’s inverse is also symmetric.</p>

<h4 id="32-gradient-is-a-column-vector">3.2 <strong>Gradient is a Column Vector</strong></h4>
<hr />

<p>The second term becomes $2 X^T X w$ and the third becomes $2 X^T y$.</p>

\[0 = 2 X^T X w - 2 X^T y\]

<p>Skipping ahead…</p>

\[w = (X^T X)^{-1} X^T y\]

<p>Okay, this was all fairly simple. We can also read this as $w = \frac{\text{Cov}(X, y)}{\text{Var}(X)}$ to view this from another angle.</p>

<p>I hope everything seems relatively well-motivated thus far. However, there are certain assumptions that have already been made as well as other issues that have been glossed over.</p>

<p>Prominently, we defined the loss function to be the mean-squared error $\text{MSE}(y, Xw)$. This is equivalent to minimizing the $L_2$ norm of the residuals. But <em>why</em> use mean-squared error? Why not mean absolute error (MAE) or mean-cubic error?</p>

<p>There are many reasons why MSE is a empirically nice loss function to use. It’s differentiable unlike MAE and doesn’t place as much weight on outliers as mean errors of higher order terms does. $L_2$ is also a Hilbert space while $L_p$ for $p \geq 1, p \neq 2$ is not (whatever that means). But we still <em>chose</em> MSE. These are justifications, not derivations from first principles.</p>

<p>I find that everything fits better in my head when we don’t choose an arbitrary loss function but are <em>forced</em> into that choice from the assumptions we make. My professor once said (paraphrasing) being Bayesian is all about being up-front and honest with our beliefs. We want to honestly represent our assumptions here. A good first step towards that is to do linear regression probabilistically (we’ll get to the Bayesian bits eventually).</p>

<h1 id="4-maximum-likelihood-estimation">4. <strong>Maximum Likelihood Estimation</strong></h1>
<hr />

<p>Let’s begin by placing a distribution over the noise. Say, for example, we choose $\epsilon_x \sim \mathcal{N}(0, \sigma^2)$. So we have:</p>

\[\epsilon_x \sim \mathcal{N}(0, \sigma^2)\]

\[y_i \sim \mathcal{N}(w^T x_i, \sigma^2)\]

<p>The <strong>likelihood function</strong> is:</p>

\[\mathcal{L}(w \mid \mathcal{D}) = p(\mathcal{D} \mid w)\]

<p>We want to maximize the likelihood of observing the data (what does this mean?). Our data points $y_i$ are i.i.d. since they’re all drawn from $\mathcal{N}(w^T x_i, \sigma^2)$ (identical) and are conditionally independent on the mean and variance. So we have:</p>

\[p(\mathcal{D} \mid w) = p(y_1, \dots, y_N \mid w, x_1, \dots, x_n, \sigma^2)\]

\[= \prod_{i = 1}^n \mathcal{N}(y_i ; w^T x_i, \sigma^2)\]

\[= \prod_{i = 1}^n \frac{1}{\sqrt{2 \pi \sigma^2}} \exp \left \{ - \frac{1}{2 \sigma^2} (y_i - w^T x_i)^2    \right \}\]

<p>The product of exponentials becomes a sum within the exponential. So we have:</p>

\[= \frac{1}{(2 \pi \sigma^2)^\frac{n}{2}} \exp \left \{ - \frac{1}{2 \sigma^2} \sum_{i = 1}^n (y_i - w^T x_i)^2    \right \}\]

<p>We can re-write these as inner products and save ourselves a lot of mental load. A physics PhD student I was working with actually pointed this out to me and I never looked back (thank you!)</p>

\[= \frac{1}{(2 \pi \sigma^2)^\frac{n}{2}} \exp \left \{ - \frac{1}{2 \sigma^2} (y - Xw)^T (y - Xw)    \right \}\]

<p>Now, we want to maximize this likelihood with respect to $w$. Since the logarithm is a monotonic transformation, the log-likelihood and the likelihood have the same extrema. So, we have:</p>

\[w_{\text{MLE}} = \argmax_w \ p(\mathcal{D} \mid w) = \argmax_w \ \log p(\mathcal{D} \mid w)\]

<p>So we have:</p>

\[\log p(\mathcal{D} \mid w) = - \frac{1}{2 \sigma^2} (y^Ty + w^T X^T X w - 2 y^T X w) - \frac{n}{2} \log(2 \pi \sigma^2)\]

\[0 = \frac{\partial}{\partial w} \log p(D \mid w) = - \frac{1}{2 \sigma^2} \frac{\partial}{\partial w} (y^T y + w^T X^T X w - 2 y^T X w)\]

<p>For convenience’s sake, I’ll treat the gradient as a column vector although I generally prefer the other way.</p>

<p>So we have:</p>

\[0 = 2 X^T X w - 2 X^T y\]

\[X^T y = X^T X w\]

\[w_{\text{MLE}} = (X^T X)^{-1} X^T y\]

<p>This is no different from what we’ve already seen. But we can also derive a maximum likelihood estimate for the noise variance.</p>

\[0 = \frac{\partial}{\partial \sigma^2} \log p(\mathcal{D} \mid w) = \frac{\partial}{\partial \sigma^2} \left [ - \frac{1}{2 \sigma^2} (y^Ty + w^T X^T X w - 2 y^T X w) - \frac{n}{2} \log(2 \pi \sigma^2) \right ]\]

\[0 = - \frac{2 n \pi}{4 \pi \sigma^2} + \frac{1}{2 \sigma^4} (y - Xw)^T (y - Xw)\]

\[\frac{n}{\sigma^2} = \frac{1}{\sigma^4} (y - Xw)^T (y - Xw)\]

\[\sigma^2_{\text{MLE}} = \frac{1}{n} (y - Xw)^T (y - Xw)\]

<p>This is a little better - its nice to be able to estimate the variance of the noise as well.</p>

<p>Math is nice but we need to check whether or not this formula actually works. We implement these basic formulas to generate the following image.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import torch
import matplotlib.pyplot as plt

torch.manual_seed(42)

x = 30.0 * torch.rand(100)
y = 3.0 * x + 40.0 + torch.randn(100) * torch.sqrt(torch.tensor(5.0))

X = torch.stack([torch.ones(100), x], dim=1)

w_MLE = torch.linalg.inv(X.T @ X) @ X.T @ y
y_pred = X @ w_MLE

sigma_2_mle = ((y - y_pred).T @ (y - y_pred)) / (100 - 2)
slope_str = f"Estimated Slope, Intercept, Noise Variance: {w_MLE[1]:.4f}, {w_MLE[0]:.4f}, {sigma_2_mle:.4f}, True Noise Variance: {5.0:.4f}"
# Estimated Slope: 2.9656, Intercept: 40.5160, Noise Variance: 3.3836, True Noise Variance: 5.0000

plt.title(slope_str, fontsize=10, color="black")
plt.plot(x, y, "o", label="Noisy Targets", color="blue")
plt.plot(x, y_pred, "-*",label="Predictions", color="red")
plt.legend()
plt.show()
</code></pre></div></div>

<p><img src="/images/MLE_linear_regression.png" alt="MLE Linear Regression" /></p>

<p>However, the MLE of the variance is a biased estimator. <strong>Bessel’s correction</strong> divides $(y - Xw)^T (y - Xw)$ by $(n - p)$ where $p$ is the number of <strong>degrees of freedom</strong> to get a unbiased estimator (in the above case, $p = 2$ - slope, intercept). The following GIF shows how different estimators of the variance change w.r.t. different variances. To be honest, I initially found that the MLE / Bessel estimators were initially overestimating variance but figured out this was because of the random seed. Over different random seeds, the MLE estimator tended to generally underestimate the true noise variance.</p>

<p><img src="/images/lin_reg_mle.gif" alt="Variance Estimator GIF" /></p>

<p>The code for that can be found <a href="https://github.com/alexali04/function_fitting/blob/main/func_learning/experiments/bayesian_lr/lin_reg.py">here</a>.</p>

<h4 id="41-issues-with-mle">4.1 <strong>Issues with MLE</strong></h4>
<hr />

<p>There are several issues with maximum likelihood estimation. But the most glaring one, to me at least, is that it fundamentally answers the wrong question. Do we <em>really</em> care about the probability of the data given some parameter setting? I think the more natural question is the probability of some parameter setting given the data.</p>

<h1 id="5-map">5. <strong>MAP</strong></h1>
<hr />

<p>One way to do this is with <strong>MAP</strong> or <strong>Maximum a Posteriori</strong> estimation.</p>

<p>Bayes Rule states:</p>

\[p(w \mid \mathcal{D}) = \frac{p(\mathcal{D} \mid w) p(w)}{p(\mathcal{D})}\]

<p>The left-hand side is called the <strong>posterior distribution</strong>. It’s proportional to the likelihood multiplied with the prior distribution. The prior represents our beliefs about the data before we have observed the data - the posterior represents our updated beliefs after having observed the data (likelihood).</p>

<p>So we need to place a prior distribution on $w$. So we can specify:</p>

\[w \sim \mathcal{N}(0, \alpha^2 I)\]

\[\epsilon_x \sim \mathcal{N}(0, \sigma^2)\]

<p>So the joint distribution can be written as a multivariate Gaussian.</p>

\[y \mid w, X, \sigma^2 \sim \mathcal{N}(Xw, \sigma^2 I)\]

<p>The MAP estimate $w_{\text{MAP}}$ is the parameter setting which maximizes the probability of the parameter given the data. So we want:</p>

\[w_{\text{MAP}} = \argmax_{w} \ p(w \mid \mathcal{D})\]

<p>Again, we can take the logarithm, so we have:</p>

\[w_{\text{MAP}} = \argmax_{w} \ \log p(w \mid \mathcal{D})\]

\[= \argmax_{w} \ \log p(\mathcal{D} \mid w) + \log p(w) - \log(\mathcal{D})\]

<p>The denominator of Bayes rule is called the marginal likelihood or the partition function or the evidence. Since it doesn’t depend on $w$, we can just ignore it in finding $w_{\text{MAP}}$. So we have:</p>

\[0 = \frac{\partial}{\partial w} \log p(\mathcal{D} \mid w) + \log p(w)\]

<p>Taking the logarithm of normal distributions,</p>

\[= \frac{\partial}{\partial w} \left [ 
- \frac{1}{2 \sigma^2} (y - Xw)^T (y - Xw) - \frac{n}{2} \log (2 \pi \sigma^2) - \frac{1}{2 \alpha^2} w^T w - \frac{d}{2} \log (2 \pi \alpha^2)
\right ]\]

<p>We’ve performed bits and pieces of this derivative above. So we get</p>

\[0 = \frac{X^T y}{\sigma^2} - \frac{w}{\alpha^2} - \frac{X^T X w}{\sigma^2}\]

\[0 = X^T y - \frac{\sigma^2 w}{\alpha^2} - X^T X w\]

<p>Define $\lambda = \frac{\sigma^2}{\alpha^2}$. Then, we have:</p>

\[0 = X^T y - \lambda w - X^T X w\]

\[(X^T X + \lambda I)w = X^T y\]

\[w_{\text{MAP}} = (X^T X + \lambda I)^{-1} X^T y\]

<p>We can reach this formula by finding:</p>

\[w_{\text{MAP}} = \argmin_{w} (y - Xw)^T (y - Xw) + \lambda w^T w\]

<p>In other words, we can recover $L_2$ regularization by assuming Gaussian noise and a Gaussian prior. I like this probabilistic approach much better because it all feels very motivated from our assumptions.</p>

<p>We can also derive MAP solutions for the noise and weight variances. First, the MAP solution for the noise variance is the same as the MLE solution because it’s not affected by the prior.</p>

\[0 = \frac{\partial}{\partial \alpha^2} \left [ 
 - \frac{1}{2 \alpha^2} w^T w - \frac{d}{2} \log (2 \pi \alpha^2)
\right ]\]

\[= \frac{1}{2 \alpha^4} w^T w - \frac{d}{2 \alpha^2}\]

\[\alpha^2_{\text{MAP}} = \frac{1}{d} w_{\text{MAP}}^T w_{\text{MAP}}\]

<p>If we send the prior variance of the weight to $0$, i.e. $\alpha^2 \to 0$, then the regularization coefficient $\lambda$ grows very large so the weights move towards $0$. Similarly, if we send the noise variance $ \sigma^2 \to \infty$, we’ll see a similar result.</p>

<h1 id="6-bayesian-linear-regression">6. <strong>Bayesian Linear Regression</strong></h1>

<h4 id="61-marginal-likelihood">6.1 <strong>Marginal Likelihood</strong></h4>

<p>I want to talk briefly about the marginal likelihood (evidence, partition function, normalizing constant) which is the denominator in Bayes rule. By the sum and product rules of probability, we have:</p>

\[p(\mathcal{D}) = \int p(\mathcal{D} \mid w) \ p(w) \ dw\]

<p>By marginalizing out $w$ (hence the name <strong>marginal</strong> likelihood), we get a term which tells us the likelihood of the data, conditioned on hyperparameters. This also lets us directly perform hyperparameter optimization. Contrast optimizing this quantity with other hyperparameter optimization techniques like grid search which is exponential in the number of hyperparameter-combinations or random search which is … random.</p>

<p>Of course, the downside of this method  (<strong>marginal likelihood optimization</strong> or <strong>Type 2 MLE</strong>) is that it involves an integral which is often intractable. No free lunch strikes again (or does it?…)</p>

<p>We’ll use the same prior and noise distribution as before and compute the marginal likelihood. Buckle up.<sup id="fnref:3"><a href="#fn:3" class="footnote" rel="footnote" role="doc-noteref">3</a></sup></p>

\[p(\mathcal{D}) = \int \mathcal{N}(y ; Xw, \sigma^2 I) \ \mathcal{N}(w ; 0, \alpha^2 I) \ dw\]

\[= c \int \exp \left \{
- \frac{1}{2} \left [
    \frac{(y - Xw)^T (y - Xw)}{\sigma^2} + \frac{w^T w}{\alpha^2}
    \right ]
\right \} \ dw\]

\[= c \int \exp \left \{
- \frac{1}{2} \left [
    \frac{y^T y + w^T X^T X w - 2 w^T X^T y}{\sigma^2} + \frac{w^T w}{\alpha^2}
    \right ]
\right \} dw\]

<p>The strategy here is to transform the exponential inside the integrand into an unnormalized probability distribution, or the posterior, $p(w \mid \mathcal{D}) \propto p(\mathcal{D} \mid w) p(w)$. Moving the $y^T y$ term out of the integral (since it doesn’t depend on $ws), we get:</p>

\[= c' \int \exp \left \{
- \frac{1}{2} \left [
    \frac{w^T X^T X w - 2 w^T X^T y}{\sigma^2} + \frac{w^T w}{\alpha^2}
    \right ]
\right \} dw\]

\[= c' \int \exp \left \{
- \frac{1}{2} \left [
    w^T \left ( \frac{X^T X}{\sigma^2} + \frac{I}{\alpha^2} \right ) w - \frac{2 w^T X^T y}{\sigma^2}
    \right ]
\right \} dw\]

<p>We can ascertain the precision matrix $\Lambda = \frac{X^T X}{\sigma^2} + \frac{I}{\alpha^2}$. We want the integrand to be (ignoring the exponential), of the form $(w - \mu)^T \Lambda (w - \mu)$. We have:</p>

\[(w - \mu)^T \Lambda (w - \mu) = w^T \Lambda w + \mu^T \Lambda \mu - 2 w^T \Lambda \mu\]

<p>By inspection, we know that $2 w^T \Lambda \mu = \frac{2 w^T X^T y}{\sigma^2}$. So we have $\Lambda \mu = \frac{X^T y}{\sigma^2}, \mu = \Lambda^{-1} \frac{X^T y}{\sigma^2}$.</p>

<p>So we have:</p>

\[w^T \Lambda w - 2 w^T \Lambda \mu = (w - \mu)^T \Lambda (w - \mu) - \mu^T \Lambda \mu\]

<p>So we have:</p>

\[p(\mathcal{D}) = c' \int \exp \left \{ - \frac{1}{2} \left [
(w - \mu)^T \Lambda (w - \mu) - \mu^T \Lambda \mu
\right ]
\right \} \ dw\]

<p>Finally, we can take out the term $\mu^T \Lambda \mu$ to get:</p>

\[p(\mathcal{D}) = c'' \int \exp \left \{ - \frac{1}{2} 
(w - \mu)^T \Lambda (w - \mu)
\right \} \ dw\]

<p>There’s a nice integral trick to know here. If we have a probability distribution $f(x) = \frac{\hat{f}(x)}{Z}$ where $Z$ is the normalizing constant, it follows that the integral of the unnormalized probability distribution is $\int \hat{f}
(x) \ dx = \frac{1}{Z}$.</p>

<p>The integrand corresponds to an unnormalized normal distribution $\mathcal{UN}(w; \mu, \Lambda^{-1})$ (my own notation :P). So we have:</p>

\[\int \exp \left \{ - \frac{1}{2} 
(w - \mu)^T \Lambda (w - \mu)
\right \} \ dw = (2 \pi )^{\frac{d}{2}} \det(\Lambda^{-1})^{\frac{1}{2}}\]

\[= \frac{(2 \pi )^{\frac{d}{2}}}{\det(\Lambda)^{\frac{1}{2}}}\]

<p>Finally, we’ve reached a closed form solution.</p>

\[p(\mathcal{D}) = c'' \frac{(2 \pi )^{\frac{d}{2}}}{\det(\Lambda)^{\frac{1}{2}}}\]

\[= \frac{\exp \left \{ - \frac{1}{2} \left [ \frac{y^T y}{\sigma^2} + \mu^T \Lambda \mu  \right ]   \right \}}{(2 \pi \sigma^2)^{\frac{n}{2}} (2 \pi \alpha^2)^{\frac{d}{2}}}
\frac{(2 \pi )^{\frac{d}{2}}}{\det(\Lambda)^{\frac{1}{2}}}\]

<p>However, we can again, re-write this slightly. First of all, observe that:</p>

\[\mu^T \Lambda \mu = \frac{y^T X}{\sigma^2} \Lambda^{-1} \Lambda \Lambda^{-1} \frac{X^T y}{\sigma^2}\]

\[= \frac{y^T X \Lambda^{-1} X^T y}{\sigma^4}\]

<p>So let’s re-write the term in this exponential as:</p>

\[p(\mathcal{D}) = \frac{\exp \left \{ - \frac{1}{2} y^T \left [ \frac{I}{\sigma^2} + \frac{X \Lambda^{-1} X^T}{\sigma^4}  \right ] y   \right \}}{(2 \pi \sigma^2)^{\frac{n}{2}} (2 \pi \alpha^2)^{\frac{d}{2}}}
\frac{(2 \pi )^{\frac{d}{2}}}{\det(\Lambda)^{\frac{1}{2}}}\]

<p>Define $\Lambda_0 = \frac{I}{\sigma^2} + \frac{X \Lambda^{-1} X^T}{\sigma^4}$. So we have</p>

\[p(\mathcal{D}) = \frac{\exp \left \{ - \frac{1}{2} y^T \Lambda_0 y   \right \}}{(2 \pi \sigma^2)^{\frac{n}{2}} (2 \pi \alpha^2)^{\frac{d}{2}}}
\frac{(2 \pi )^{\frac{d}{2}}}{\det(\Lambda)^{\frac{1}{2}}}\]

<p>We can honestly leave it here. But we won’t because we know there is a Gaussian distribution hiding <em>somewhere</em> in there. I’m gonna go ahead and take a shot in the dark that $p(\mathcal{D}) = \mathcal{N}(0, \Lambda_0^{-1})$. Let’s test that hypothesis.</p>

<p>I’ll introduce two lemmas which are generally quite useful in Bayesian statistics. The first one is the <strong>Woodbury Matrix Identity</strong>. It states:</p>

\[(A + UCV)^{-1} = A^{-1} - A^{-1} U (C^{-1} + V A^{-1} U)^{-1} V A^{-1}\]

<p>Define $C = \frac{\Lambda^{-1}}{\sigma^4}, U = -X, V = X^T, A = \frac{I}{\sigma^2}$. Then, we have:</p>

\[\Lambda_0^{-1} = \sigma^2 I + \sigma^2 I X (\sigma^4 \Lambda - \sigma^2 X^T X)^{-1} X^T \sigma^2 I\]

<p>Substitute in $\Lambda = \frac{X^T X}{\sigma^2} + \frac{I}{\alpha^2}$.</p>

\[\Lambda_0^{-1} = \sigma^2 I + \sigma^4 X \left (\sigma^4 \left ( \frac{X^T X}{\sigma^2} + \frac{I}{\alpha^2} \right ) - \sigma^2 X^T X \right )^{-1} X^T\]

\[\Lambda_0^{-1} = \sigma^2 I + \sigma^4 X \left ( 
    \sigma^2 X^T X + \frac{\sigma^4}{\alpha^2} I - \sigma^2 X^T X
    \right )^{-1} X^T\]

\[= \sigma^2 I + \sigma^4 X \left ( 
    \frac{\sigma^4}{\alpha^2} I 
    \right )^{-1} X^T\]

\[= \sigma^2 I + \alpha^2 X X^T\]

<p>When I derived this for the first time, I was actually surprised by how nice this matrix inverse is.<sup id="fnref:4"><a href="#fn:4" class="footnote" rel="footnote" role="doc-noteref">4</a></sup></p>

<p>Next, let’s compute the determinant of this. What I’m hoping for is that the determinant of the covariance matrix will absorb some of the straggling terms in the normalizing coefficient(s). Recall, we have:</p>

\[p(\mathcal{D}) = \frac{\exp \left \{ - \frac{1}{2} y^T \Lambda_0^{-1} y   \right \}}{(2 \pi \sigma^2)^{\frac{n}{2}} (2 \pi \alpha^2)^{\frac{d}{2}}}
\frac{(2 \pi )^{\frac{d}{2}}}{\det(\Lambda)^{\frac{1}{2}}}\]

<p>First, we can immediately cancel out $(2 \pi)^{\frac{d}{2}}$.</p>

\[p(\mathcal{D}) = \frac{\exp \left \{ - \frac{1}{2} y^T \Lambda_0^{-1} y   \right \}}{(2 \pi \sigma^2)^{\frac{n}{2}} (\alpha^2)^{\frac{d}{2}} \det(\Lambda)^{\frac{1}{2}}}\]

<p>So now, we’ll use the <strong>determinant lemma</strong> to compute $\det(\Lambda_0^{-1})$. The determinant lemma states:</p>

\[\det(A + UWV^T) = \det(W^{-1} + V^T A^{-1} U) \det(W) \det(A)\]

\[\det(\sigma^2 I + X \alpha^2 I X^T) = \det(\frac{I}{\alpha^2} + X^T \frac{I}{\sigma^2} X) \det(\alpha^2 I) \det (\sigma^2 I)\]

<p>Recall that $\Lambda = \frac{I}{\alpha^2} + \frac{X^T X}{\sigma^2}$. So we have:</p>

\[\det(\Lambda_0^{-1}) = \det(\Lambda) (\alpha^2)^{d} (\sigma^2)^{n}\]

\[\det(\Lambda_0^{-1})^{\frac{1}{2}} = \det(\Lambda)^{\frac{1}{2}} (\alpha^2)^{\frac{d}{2}} (\sigma^2)^{\frac{n}{2}}\]

<p>So in conclusion, we have:</p>

\[p(\mathcal{D}) = \frac{\exp \left \{ - \frac{1}{2} y^T \Lambda_0^{-1} y \right \}}{(2 \pi)^{\frac{n}{2}} \det(\Lambda_0^{-1})^{\frac{1}{2}}}\]

\[\boxed{\mathcal{D} \sim \mathcal{N}(y; 0, \sigma^2 I + \alpha^2 X X^T)}\]

<p>Phew. This evidence quantity is very hard to compute so we try and avoid it best we can. But with nice models like linear-Gaussian, we can do it.</p>

<p>Fun fact: the marginal likelihood is often written with a $Z$ because it stands for <em>Zustandssumme</em> or “sum over states” in German.</p>

<h4 id="62-posterior-distribution">6.2 <strong>Posterior Distribution</strong></h4>

<p>Finally, let’s compute the normalized posterior distribution. Specifically, we want $p(w \mid \mathcal{D})$. Good news - we’ve already done this! The integrand of the marginal likelihood is our answer: we have,</p>

\[p(w \mid \mathcal{D}) = \mathcal{N}(\mu, \Lambda^{-1})\]

\[\Lambda = \frac{X^T X}{\sigma^2} + \frac{I}{\alpha^2}\]

\[\mu = \Lambda^{-1} \frac{X^T y}{\sigma^2}\]

<p>There are very simple ways to derive this from Gaussian identities.<sup id="fnref:5"><a href="#fn:5" class="footnote" rel="footnote" role="doc-noteref">5</a></sup> But since most of the work is already kind of done for us, let’s derive it the “hard” way.</p>

\[p(w \mid \mathcal{D}) = \frac{p(\mathcal{D} \mid w) p(w)}{p(\mathcal{D})}\]

\[= \frac{\mathcal{N}(y; Xw, \sigma^2 I) \mathcal{N}(w; 0, \alpha^2 I)}{\mathcal{N}(y; 0, \alpha^2 X X^T + \sigma^2 I)}\]

<p>From the previous section, we can write the denominator:</p>

\[D_e = \frac{(2 \pi \sigma^2)^{\frac{n}{2}} \det(\Lambda)^{\frac{1}{2}} (\alpha^2)^{\frac{D}{2}}}{\exp(- \frac{1}{2} [ \frac{y^T y}{\sigma^2} - \mu^T \Lambda \mu])}\]

<p>and the numerator:</p>

\[N_u = \frac{\exp \left \{  - \frac{1}{2 \sigma^2} (y - Xw)^T (y - Xw) - \frac{1}{2 \alpha^2} w^T w  \right \}}{(2 \pi \sigma^2)^{\frac{n}{2}} (2 \pi \alpha^2)^{\frac{D}{2}}}\]

<p>Now, most of the constants cancel out except for $(2 \pi)^{\frac{D}{2}}$ and $\det(\Lambda)^{\frac{1}{2}}$. Let $E(w)$ be the argument inside the exponential.</p>

\[\frac{N_u}{D_e} = \frac{E(w)}{\sqrt{(2 \pi)^D \det(\Lambda^{-1})}}\]

<p>Finally, let’s put an end to this long fight and compute $E(w)$. Just be careful about signs.</p>

\[E(w) = - \frac{1}{2} \left [   
\frac{(y - Xw)^T(y - Xw)}{\sigma^2} + \frac{w^T w}{\alpha^2} + \mu^T \Lambda \mu - \frac{y^T y}{\sigma^2}
\right ]\]

\[E(w) = - \frac{1}{2} \left [   
\frac{y^T y + w^T X^T X w - 2 w^T X^T y}{\sigma^2} + \frac{w^T w}{\alpha^2} + \mu^T \Lambda \mu - \frac{y^T y}{\sigma^2}
\right ]\]

<p>Canceling out the $\frac{y^T y}{\sigma^2}$ terms,</p>

\[= - \frac{1}{2} \left [   
    w^T \left (\frac{X^T X}{\sigma^2} + \frac{I}{\alpha^2} \right ) w - 2
\frac{w^T X^T y}{\sigma^2} + \mu^T \Lambda \mu 
\right ]\]

\[= - \frac{1}{2} \left [   
    w^T \Lambda w - 2 w^T \Lambda \mu + \mu^T \Lambda \mu 
\right ]\]

<p>In completing the square in the previous section, we found this to be equal to:</p>

\[= - \frac{1}{2} \left [   
    (w - \mu)^T \Lambda (w - \mu) - \mu^T \Lambda \mu + \mu^T \Lambda \mu 
\right ]\]

\[= - \frac{1}{2} \left [   
    (w - \mu)^T \Lambda (w - \mu)
\right ]\]

<p>So we have:</p>

\[p(w \mid \mathcal{D}) = \frac{\exp(- \frac{1}{2} (w - \mu)^T \Lambda (w - \mu))}{\sqrt((2 \pi)^{D} \det(\Lambda^{-1}))}\]

\[\boxed{w \mid \mathcal{D} \sim \mathcal{N}(\mu, \Lambda^{-1})}\]

<p>So we have an estimate for $w$. But how do we actually make point predictions?</p>

<h4 id="63-predictive-distribution">6.3 <strong>Predictive Distribution</strong></h4>

<p>The predictive distribution is pretty simple.</p>

\[p(y_* \mid X_*, \alpha^2, \sigma^2, \mathcal{D}) = \int p(y_* \mid X_*, w, \sigma^2) p(w \mid \mathcal{D}, \alpha^2) dw\]

<p>This is called the <strong>Bayesian Model Average</strong>. It is robust to overfitting and I like it very much. It weights our predictions for different output points $y_*$ by the posterior probability of the coefficient $w$.</p>

<h1 id="7-conclusion">7. <strong>Conclusion</strong></h1>

<p>This post is nearly <em>X</em> words long with a lot of tedious math so if you got through it, I think you should feel proud. We went over linear regression with MSE, MAP, and the BMA which is quite a lot. I hope you learned something too! I would estimate that the knowledge in this post probably took around 9 months to accumulate? Obviously, this metric is bad because I wasn’t actively seeking out different perspectives on linear regression. I learned the standard MSE perspective in my first machine learning class and then MAP and the BMA I learned in a Bayesian machine learning class. Very interesting stuff.</p>

<p>The</p>

<h2 id="8-footnotes">8. <strong>Footnotes</strong></h2>
<hr />

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1">
      <p>All of these examples work with feature transformations on $X$, i.e. replacing $X$ with $\Phi$. Linear regression is super powerful… when it can be made non-linear! <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>Linear algebra is your friend. Probably your best friend, actually. It allows a very easy and simple derivation of linear regression.</p>

      <p>We know that $y$ is a vector and the solution $X w$ is the vector which is closest to $y$. In other words, $y$ is an orthogonal projection onto $\text{span}(X)$. This means the error vector $e = y - Xw$ is orthogonal to $X$. So we have:</p>

\[X^T e = 0\]

\[X^T (y - Xw) = 0\]

\[X^T y - X^T X w = 0\]

\[w = (X^T X)^{-1} X^T y\]
      <p><a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p>Bayesian statistics math is notoriously tedious. There’s a much easier way to do this by treating it as a Gaussian Process. I’ll derive it quickly here. Suppose $w \sim \mathcal{N}(0, \alpha^2 I), \epsilon_x \sim \mathcal{N}(0, \sigma^2 I)$.</p>

\[y = Xw + \epsilon_x\]

\[E[y]= E[Xw] + E[\epsilon_x]\]

      <p>$E[\epsilon_x] = 0$ since it has mean $0$. For the same reason,</p>

\[E[Xw] = X E[w] = 0\]

      <p>So $E[y] = 0$. Next, we’ll compute the covariance matrix.</p>

\[E[y y^T] = E[(Xw + \epsilon_x)(Xw + \epsilon_x)^T]\]

      <p>Order matters here. These are all matrices so we cannot interchange the order of multiplication between $Xw$ and $w^T X^T$.</p>

\[= E[Xw w^T X^T + \epsilon_x \epsilon_x^T + \epsilon_x w^T X^T + X w \epsilon_x^T ]\]

      <p>The other terms go to $0$. Since $\epsilon_x$ and $w$ are independent, $E[\epsilon_x w] = E[\epsilon] E[w]$ = 0.</p>

\[= X E[ww^T] X^T + E[\epsilon_x \epsilon_x^T]\]

\[= \sigma^2 I + \alpha^2 X X^T\]

      <p>Much easier… : ) <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4">
      <p>Sometimes it’s a lot nicer to use the precision matrix (inverse of covariance matrix). I kind of want to make a post later about what the precision matrix <em>actually</em> means - it has something to do with partial correlations. Here, the precision matrix is quite ugly but the covariance matrix is really nice. <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5">
      <p>Once we know the mean $\mu$ and precision matrix $\Lambda$, we can kind of just infer that $w \mid \mathcal{D} \sim \mathcal{N}(\mu, \Lambda^{-1})$. I made a mistake which confused me for a few days - I thought $p(w \mid \mathcal{D}) = \frac{\mathcal{N}(\mu, \Lambda)}{\mathcal{N}(0, \alpha^2 XX^T + \sigma^2 I)}$. But this isn’t true - we need to integrate the unnormalized $p(\mathcal{D} \mid w) p(w)$ to get the marginal likelihood. I guess what I’m trying to get is… Bayes formula never lies?</p>

      <p>With normal-normal models, we can also just take advantage of some nice conditional Gaussian identities.</p>

      <p>Suppose</p>

\[p(x) = \mathcal{N}(x ; \mu, \Lambda^{-1})\]

\[p(y \mid x) = \mathcal{N}(y; Ax + b, L^{-1})\]

      <p>Then,</p>

\[p(x \mid y) = \mathcal{N}(x; \Sigma(A^T L(y - b) + \Lambda \mu), \Sigma)\]

\[\Sigma = (\Lambda + A^T L A)^{-1}\]

      <p>This will naturally give us our result. But, it’s good for our confidence to do it the hard (redundant, inefficient, not-clever) way at least once. <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[1. Introduction Things are easy when they’re simple. As far as curves go, linear curves are about as nice as it gets.]]></summary></entry></feed>